# Documentação Swagger/OpenAPI para API de Cultivo de Plantas

Vou implementar adocumentaçãoSwagger/OpenAPIparasuaAPIdecultivodeplantasusandoopacote`swaggo`(queéomaispopularparaGo).Aquiestáaimplementaçãocompleta:

## 1. Instalação das dependências

Primeiro, adicione as dependências ao seu `go.mod`:

```bash
go get -u github.com/swaggo/swag/cmd/swag@latest
go get -u github.com/swaggo/gin-swagger@latest
go get -u github.com/swaggo/files
```

## 2. Configuração do Swagger

### `cmd/api/main.go` (atualizado)

```go
package main

import (
 "log"
 "net/http"

 "github.com/gin-gonic/gin"
 _ "github.com/yourusername/plant-cultivation-api/docs" // docs is generated by Swag CLI
 "github.com/yourusername/plant-cultivation-api/internal/config"
 "github.com/yourusername/plant-cultivation-api/internal/infrastructure/database"
 "github.com/yourusername/plant-cultivation-api/internal/infrastructure/server"
 swaggerFiles "github.com/swaggo/files"
 ginSwagger "github.com/swaggo/gin-swagger"
)

// @title Plant Cultivation API
// @version 1.0
// @description API para gerenciamento de cultivo de plantas
// @termsOfService http://swagger.io/terms/

// @contact.name API Support
// @contact.url http://www.example.com/support
// @contact.email support@plantcultivation.com

// @license.name Apache 2.0
// @license.url http://www.apache.org/licenses/LICENSE-2.0.html

// @host localhost:8080
// @BasePath /api/v1
// @schemes http
func main() {
 // ... (código existente)
}
```

## 3. Documentação dos Controladores

### `internal/controller/plant_controller.go` (atualizado)

```go
package controller

import (
 // ... (imports existentes)
 "github.com/yourusername/plant-cultivation-api/internal/domain/models"
)

// PlantController handles HTTP requests for plants
type PlantController struct {
 plantService *service.PlantService
}

// NewPlantController creates a new PlantController
func NewPlantController(plantService *service.PlantService) *PlantController {
 return &PlantController{plantService: plantService}
}

// CreatePlant godoc
// @Summary Create a new plant
// @Description Add a new plant to the cultivation system
// @Tags plants
// @Accept  json
// @Produce  json
// @Param plant body models.Plant true "Plant object that needs to be added"
// @Success 201 {object} models.Plant
// @Failure 400 {object} map[string]interface{}
// @Failure 500 {object} map[string]interface{}
// @Router /plants [post]
func (c *PlantController) CreatePlant(ctx *gin.Context) {
 // ... (implementação existente)
}

// GetAllPlants godoc
// @Summary Get all plants
// @Description Get details of all plants
// @Tags plants
// @Accept  json
// @Produce  json
// @Success 200 {array} models.Plant
// @Failure 500 {object} map[string]interface{}
// @Router /plants [get]
func (c *PlantController) GetAllPlants(ctx *gin.Context) {
 // ... (implementação existente)
}

// GetPlantByID godoc
// @Summary Get plant by ID
// @Description Get details of a specific plant
// @Tags plants
// @Accept  json
// @Produce  json
// @Param id path int true "Plant ID"
// @Success 200 {object} models.Plant
// @Failure 400 {object} map[string]interface{}
// @Failure 404 {object} map[string]interface{}
// @Router /plants/{id} [get]
func (c *PlantController) GetPlantByID(ctx *gin.Context) {
 // ... (implementação existente)
}

// UpdatePlant godoc
// @Summary Update a plant
// @Description Update an existing plant
// @Tags plants
// @Accept  json
// @Produce  json
// @Param id path int true "Plant ID"
// @Param plant body models.Plant true "Updated plant object"
// @Success 200 {object} models.Plant
// @Failure 400 {object} map[string]interface{}
// @Failure 404 {object} map[string]interface{}
// @Failure 500 {object} map[string]interface{}
// @Router /plants/{id} [put]
func (c *PlantController) UpdatePlant(ctx *gin.Context) {
 // ... (implementação existente)
}

// DeletePlant godoc
// @Summary Delete a plant
// @Description Delete an existing plant
// @Tags plants
// @Accept  json
// @Produce  json
// @Param id path int true "Plant ID"
// @Success 200 {object} map[string]interface{}
// @Failure 400 {object} map[string]interface{}
// @Failure 500 {object} map[string]interface{}
// @Router /plants/{id} [delete]
func (c *PlantController) DeletePlant(ctx *gin.Context) {
 // ... (implementação existente)
}
```

## 4. Atualização do Servidor

### `internal/infrastructure/server/server.go` (atualizado)

```go
package server

import (
 // ... (imports existentes)
 swaggerFiles "github.com/swaggo/files"
 ginSwagger "github.com/swaggo/gin-swagger"
)

func NewServer(db *database.Database) *Server {
 router := gin.Default()

 // Swagger docs
 router.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))

 // ... (restante do código existente)

 return &Server{Router: router}
}
```

## 5. Gerando a Documentação

Crie um script `scripts/generate-swagger.sh`:

```bash
#!/bin/bash

echo "Generating Swagger docs..."
swag init -g cmd/api/main.go -o ./docs
```

Execute o script:

```bash
chmod +x scripts/generate-swagger.sh
./scripts/generate-swagger.sh
```

Isso criará uma pasta `docs` com os arquivos da documentação.

## 6. Adicionando Exemplos e Modelos

### `internal/domain/models/plant.go` (atualizado)

```go
package models

// PlantSpecies represents the species of a plant
// @Schema
type PlantSpecies string

const (
 // @Enum tomato, lettuce, strawberry, basil
 SpeciesTomato    PlantSpecies = "tomato"
 SpeciesLettuce   PlantSpecies = "lettuce"
 SpeciesStrawberry PlantSpecies = "strawberry"
 SpeciesBasil     PlantSpecies = "basil"
)

// Plant represents a plant in the cultivation system
// @Schema
type Plant struct {
 Base
 // @Example Tomato Plant
 Name          string       `gorm:"size:255;not null" json:"name"`
 // @Example tomato
 Species       PlantSpecies `gorm:"size:100;not null" json:"species"`
 // @Example 2023-05-15
 PlantingDate  string       `gorm:"size:100;not null" json:"planting_date"`
 // @Example 2023-08-20
 HarvestDate   string       `gorm:"size:100" json:"harvest_date,omitempty"`
 // @Enum growing,harvested,wilted
 // @Example growing
 Status        string       `gorm:"size:100;not null" json:"status"`
 // @Enum seedling,vegetative,flowering,fruiting,mature
 // @Example vegetative
 GrowthStage   string       `gorm:"size:100;not null" json:"growth_stage"`
 // @Example Healthy plant with no signs of disease
 Notes         string       `gorm:"type:text" json:"notes,omitempty"`
}
```

## 7. Acessando a Documentação

Após iniciar a aplicação, acesse:

```bash
http://localhost:8080/swagger/index.html
```

## 8. Configuração Adicional (Opcional)

Para incluir autenticação na documentação:

```go
// main.go
// @securityDefinitions.apikey BearerAuth
// @in header
// @name Authorization
```

## 9. Atualizando o Dockerfile

Adicione a instalação do Swag CLI no estágio de build:

```dockerfile
# Build stage
FROM golang:1.21-alpine AS builder

WORKDIR /app

# Install dependencies including swag
RUN apk add --no-cache git make gcc musl-dev && \
    go install github.com/swaggo/swag/cmd/swag@latest

# ... restante do Dockerfile
```

E atualize o comando de build:

```dockerfile
# Generate Swagger docs and build
RUN swag init -g cmd/api/main.go && \
    CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o plant-cultivation-api ./cmd/api
```

## 10. Exemplo de Resposta Personalizada

Para documentar respostas de erro, crie um struct:

```go
// ErrorResponse represents an API error response
// @Schema
type ErrorResponse struct {
    // @Example 400
    Code    int    `json:"code"`
    // @Example "invalid request payload"
    Message string `json:"message"`
}
```

E use nos endpoints:

```go
// @Failure 400 {object} ErrorResponse
```

Esta implementação fornece uma documentação Swagger/OpenAPI completa para sua API, incluindo:

- Documentação de todos os endpoints
- Modelos de request/response
- Exemplos de valores
- Enumerações para campos específicos
- Configuração para autenticação (opcional)
- Integração com o Gin
- Geração automática da UI interativa

A documentação será automaticamente atualizada quando você gerar novamente com `swag init`.
