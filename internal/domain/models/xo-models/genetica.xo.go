package models

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
)

// Genetica represents a row from 'public.genetica'.
type Genetica struct {
	ID           int64          `json:"id"`            // id
	Nome         string         `json:"nome"`          // nome
	Descricao    sql.NullString `json:"descricao"`     // descricao
	TipoEspecie  string         `json:"tipo_especie"`  // tipo_especie
	TipoGenetica string         `json:"tipo_genetica"` // tipo_genetica
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the [Genetica] exists in the database.
func (g *Genetica) Exists() bool {
	return g._exists
}

// Deleted returns true when the [Genetica] has been marked for deletion
// from the database.
func (g *Genetica) Deleted() bool {
	return g._deleted
}

// Insert inserts the [Genetica] to the database.
func (g *Genetica) Insert(ctx context.Context, db DB) error {
	switch {
	case g._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case g._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (primary key generated and returned by database)
	const sqlstr = `INSERT INTO public.genetica (` +
		`nome, descricao, tipo_especie, tipo_genetica` +
		`) VALUES (` +
		`$1, $2, $3, $4` +
		`) RETURNING id`
	// run
	logf(sqlstr, g.Nome, g.Descricao, g.TipoEspecie, g.TipoGenetica)
	if err := db.QueryRowContext(ctx, sqlstr, g.Nome, g.Descricao, g.TipoEspecie, g.TipoGenetica).Scan(&g.ID); err != nil {
		return logerror(err)
	}
	// set exists
	g._exists = true
	return nil
}

// Update updates a [Genetica] in the database.
func (g *Genetica) Update(ctx context.Context, db DB) error {
	switch {
	case !g._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case g._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with composite primary key
	const sqlstr = `UPDATE public.genetica SET ` +
		`nome = $1, descricao = $2, tipo_especie = $3, tipo_genetica = $4 ` +
		`WHERE id = $5`
	// run
	logf(sqlstr, g.Nome, g.Descricao, g.TipoEspecie, g.TipoGenetica, g.ID)
	if _, err := db.ExecContext(ctx, sqlstr, g.Nome, g.Descricao, g.TipoEspecie, g.TipoGenetica, g.ID); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the [Genetica] to the database.
func (g *Genetica) Save(ctx context.Context, db DB) error {
	if g.Exists() {
		return g.Update(ctx, db)
	}
	return g.Insert(ctx, db)
}

// Upsert performs an upsert for [Genetica].
func (g *Genetica) Upsert(ctx context.Context, db DB) error {
	switch {
	case g._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO public.genetica (` +
		`id, nome, descricao, tipo_especie, tipo_genetica` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5` +
		`)` +
		` ON CONFLICT (id) DO ` +
		`UPDATE SET ` +
		`nome = EXCLUDED.nome, descricao = EXCLUDED.descricao, tipo_especie = EXCLUDED.tipo_especie, tipo_genetica = EXCLUDED.tipo_genetica `
	// run
	logf(sqlstr, g.ID, g.Nome, g.Descricao, g.TipoEspecie, g.TipoGenetica)
	if _, err := db.ExecContext(ctx, sqlstr, g.ID, g.Nome, g.Descricao, g.TipoEspecie, g.TipoGenetica); err != nil {
		return logerror(err)
	}
	// set exists
	g._exists = true
	return nil
}

// Delete deletes the [Genetica] from the database.
func (g *Genetica) Delete(ctx context.Context, db DB) error {
	switch {
	case !g._exists: // doesn't exist
		return nil
	case g._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM public.genetica ` +
		`WHERE id = $1`
	// run
	logf(sqlstr, g.ID)
	if _, err := db.ExecContext(ctx, sqlstr, g.ID); err != nil {
		return logerror(err)
	}
	// set deleted
	g._deleted = true
	return nil
}

// GeneticaByID retrieves a row from 'public.genetica' as a [Genetica].
//
// Generated from index 'genetica_pk'.
func GeneticaByID(ctx context.Context, db DB, id int64) (*Genetica, error) {
	// query
	const sqlstr = `SELECT ` +
		`id, nome, descricao, tipo_especie, tipo_genetica ` +
		`FROM public.genetica ` +
		`WHERE id = $1`
	// run
	logf(sqlstr, id)
	g := Genetica{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, id).Scan(&g.ID, &g.Nome, &g.Descricao, &g.TipoEspecie, &g.TipoGenetica); err != nil {
		return nil, logerror(err)
	}
	return &g, nil
}

// GeneticaByNome retrieves a row from 'public.genetica' as a [Genetica].
//
// Generated from index 'genetica_unique'.
func GeneticaByNome(ctx context.Context, db DB, nome string) (*Genetica, error) {
	// query
	const sqlstr = `SELECT ` +
		`id, nome, descricao, tipo_especie, tipo_genetica ` +
		`FROM public.genetica ` +
		`WHERE nome = $1`
	// run
	logf(sqlstr, nome)
	g := Genetica{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, nome).Scan(&g.ID, &g.Nome, &g.Descricao, &g.TipoEspecie, &g.TipoGenetica); err != nil {
		return nil, logerror(err)
	}
	return &g, nil
}
