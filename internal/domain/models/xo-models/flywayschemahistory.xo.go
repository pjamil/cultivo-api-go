package models

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
	"time"
)

// FlywaySchemaHistory represents a row from 'public.flyway_schema_history'.
type FlywaySchemaHistory struct {
	InstalledRank int            `json:"installed_rank"` // installed_rank
	Version       sql.NullString `json:"version"`        // version
	Description   string         `json:"description"`    // description
	Type          string         `json:"type"`           // type
	Script        string         `json:"script"`         // script
	Checksum      sql.NullInt64  `json:"checksum"`       // checksum
	InstalledBy   string         `json:"installed_by"`   // installed_by
	InstalledOn   time.Time      `json:"installed_on"`   // installed_on
	ExecutionTime int            `json:"execution_time"` // execution_time
	Success       bool           `json:"success"`        // success
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the [FlywaySchemaHistory] exists in the database.
func (fsh *FlywaySchemaHistory) Exists() bool {
	return fsh._exists
}

// Deleted returns true when the [FlywaySchemaHistory] has been marked for deletion
// from the database.
func (fsh *FlywaySchemaHistory) Deleted() bool {
	return fsh._deleted
}

// Insert inserts the [FlywaySchemaHistory] to the database.
func (fsh *FlywaySchemaHistory) Insert(ctx context.Context, db DB) error {
	switch {
	case fsh._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case fsh._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (manual)
	const sqlstr = `INSERT INTO public.flyway_schema_history (` +
		`installed_rank, version, description, type, script, checksum, installed_by, installed_on, execution_time, success` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10` +
		`)`
	// run
	logf(sqlstr, fsh.InstalledRank, fsh.Version, fsh.Description, fsh.Type, fsh.Script, fsh.Checksum, fsh.InstalledBy, fsh.InstalledOn, fsh.ExecutionTime, fsh.Success)
	if _, err := db.ExecContext(ctx, sqlstr, fsh.InstalledRank, fsh.Version, fsh.Description, fsh.Type, fsh.Script, fsh.Checksum, fsh.InstalledBy, fsh.InstalledOn, fsh.ExecutionTime, fsh.Success); err != nil {
		return logerror(err)
	}
	// set exists
	fsh._exists = true
	return nil
}

// Update updates a [FlywaySchemaHistory] in the database.
func (fsh *FlywaySchemaHistory) Update(ctx context.Context, db DB) error {
	switch {
	case !fsh._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case fsh._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with composite primary key
	const sqlstr = `UPDATE public.flyway_schema_history SET ` +
		`version = $1, description = $2, type = $3, script = $4, checksum = $5, installed_by = $6, installed_on = $7, execution_time = $8, success = $9 ` +
		`WHERE installed_rank = $10`
	// run
	logf(sqlstr, fsh.Version, fsh.Description, fsh.Type, fsh.Script, fsh.Checksum, fsh.InstalledBy, fsh.InstalledOn, fsh.ExecutionTime, fsh.Success, fsh.InstalledRank)
	if _, err := db.ExecContext(ctx, sqlstr, fsh.Version, fsh.Description, fsh.Type, fsh.Script, fsh.Checksum, fsh.InstalledBy, fsh.InstalledOn, fsh.ExecutionTime, fsh.Success, fsh.InstalledRank); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the [FlywaySchemaHistory] to the database.
func (fsh *FlywaySchemaHistory) Save(ctx context.Context, db DB) error {
	if fsh.Exists() {
		return fsh.Update(ctx, db)
	}
	return fsh.Insert(ctx, db)
}

// Upsert performs an upsert for [FlywaySchemaHistory].
func (fsh *FlywaySchemaHistory) Upsert(ctx context.Context, db DB) error {
	switch {
	case fsh._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO public.flyway_schema_history (` +
		`installed_rank, version, description, type, script, checksum, installed_by, installed_on, execution_time, success` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10` +
		`)` +
		` ON CONFLICT (installed_rank) DO ` +
		`UPDATE SET ` +
		`version = EXCLUDED.version, description = EXCLUDED.description, type = EXCLUDED.type, script = EXCLUDED.script, checksum = EXCLUDED.checksum, installed_by = EXCLUDED.installed_by, installed_on = EXCLUDED.installed_on, execution_time = EXCLUDED.execution_time, success = EXCLUDED.success `
	// run
	logf(sqlstr, fsh.InstalledRank, fsh.Version, fsh.Description, fsh.Type, fsh.Script, fsh.Checksum, fsh.InstalledBy, fsh.InstalledOn, fsh.ExecutionTime, fsh.Success)
	if _, err := db.ExecContext(ctx, sqlstr, fsh.InstalledRank, fsh.Version, fsh.Description, fsh.Type, fsh.Script, fsh.Checksum, fsh.InstalledBy, fsh.InstalledOn, fsh.ExecutionTime, fsh.Success); err != nil {
		return logerror(err)
	}
	// set exists
	fsh._exists = true
	return nil
}

// Delete deletes the [FlywaySchemaHistory] from the database.
func (fsh *FlywaySchemaHistory) Delete(ctx context.Context, db DB) error {
	switch {
	case !fsh._exists: // doesn't exist
		return nil
	case fsh._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM public.flyway_schema_history ` +
		`WHERE installed_rank = $1`
	// run
	logf(sqlstr, fsh.InstalledRank)
	if _, err := db.ExecContext(ctx, sqlstr, fsh.InstalledRank); err != nil {
		return logerror(err)
	}
	// set deleted
	fsh._deleted = true
	return nil
}

// FlywaySchemaHistoryByInstalledRank retrieves a row from 'public.flyway_schema_history' as a [FlywaySchemaHistory].
//
// Generated from index 'flyway_schema_history_pk'.
func FlywaySchemaHistoryByInstalledRank(ctx context.Context, db DB, installedRank int) (*FlywaySchemaHistory, error) {
	// query
	const sqlstr = `SELECT ` +
		`installed_rank, version, description, type, script, checksum, installed_by, installed_on, execution_time, success ` +
		`FROM public.flyway_schema_history ` +
		`WHERE installed_rank = $1`
	// run
	logf(sqlstr, installedRank)
	fsh := FlywaySchemaHistory{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, installedRank).Scan(&fsh.InstalledRank, &fsh.Version, &fsh.Description, &fsh.Type, &fsh.Script, &fsh.Checksum, &fsh.InstalledBy, &fsh.InstalledOn, &fsh.ExecutionTime, &fsh.Success); err != nil {
		return nil, logerror(err)
	}
	return &fsh, nil
}

// FlywaySchemaHistoryBySuccess retrieves a row from 'public.flyway_schema_history' as a [FlywaySchemaHistory].
//
// Generated from index 'flyway_schema_history_s_idx'.
func FlywaySchemaHistoryBySuccess(ctx context.Context, db DB, success bool) ([]*FlywaySchemaHistory, error) {
	// query
	const sqlstr = `SELECT ` +
		`installed_rank, version, description, type, script, checksum, installed_by, installed_on, execution_time, success ` +
		`FROM public.flyway_schema_history ` +
		`WHERE success = $1`
	// run
	logf(sqlstr, success)
	rows, err := db.QueryContext(ctx, sqlstr, success)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*FlywaySchemaHistory
	for rows.Next() {
		fsh := FlywaySchemaHistory{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&fsh.InstalledRank, &fsh.Version, &fsh.Description, &fsh.Type, &fsh.Script, &fsh.Checksum, &fsh.InstalledBy, &fsh.InstalledOn, &fsh.ExecutionTime, &fsh.Success); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &fsh)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}
